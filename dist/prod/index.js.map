{"version":3,"file":"index.js","mappings":"AAAoBA,WAAWC,YAeDC,YCfZF,WAAWG,UAwB7BH,WAAWI,KAAO,CACdC,iBAAkB,SAASC,GAEvB,MAAMC,EAAW,IAAIC,EAAc,MAC7BC,EAAW,IAAIC,SAIrB,OAFCD,EAAiBE,UAAYJ,EAEvB,CACHA,SACAE,WAER,GAKJ,MAAMD,UAAsBN,YAExBU,MAA4B,KAE5BC,WAAAA,CAAYC,GACRC,QAEY,OAARD,IAGJE,KAAKF,IAAMA,EAEXd,WAAWiB,MAAMH,GAAKI,MAAMC,MAAOV,IAE/BO,KAAKJ,MAAQ,EAAkBD,UAC/BK,KAAKJ,MAAOA,MAAQI,KAEpBA,KAAKI,WAAaJ,KAAKK,KACvBL,KAAKM,cAAe,IAAIC,MAAM,SAC9BP,KAAKJ,MAAOU,cAAe,IAAIC,MAAM,YAK7C,CAEAC,KAAAA,CAAMC,EAAeC,GACjBV,KAAKI,WAAaJ,KAAKW,OACvB,IAAIC,EAAwB,CAAC,OAChBC,IAATJ,IACAG,EAAMH,KAAOA,QACFI,IAAXH,IACAE,EAAMF,OAASA,GAEnBV,KAAKJ,MAAOU,cAAe,IAAIQ,WAAW,QAASF,IACnDZ,KAAKM,cAAe,IAAIQ,WAAW,QAASF,GAChD,CACAG,IAAAA,CAAKC,GACDhB,KAAKJ,MAAOU,cAAc,IAAIW,aAAa,UAAW,CAACD,SAC3D,CAEAlB,IAAc,GAEdoB,QAAiE,KACjEC,QAAiE,KACjEC,UAAiE,KACjEC,OAAiE,KAEjEjB,WAAqB,EAEZkB,WAAa,EACbjB,KAAa,EACbkB,QAAa,EACbZ,OAAa,EAGtBa,WAAyB,cACzBC,eAAyB,EACzBC,WAAyB,GACzBC,SAAyB","sources":["webpack://VSHS/./src/Fake/EventSource.ts","webpack://VSHS/./src/Fake/WebSocket.ts"],"sourcesContent":["const EventSource = globalThis.EventSource;\n\nexport function getFakeEventSource(use_server: string|null) {\n\n    if( use_server )\n        return class EventSourceServer extends EventSource {\n            constructor(url: string) {\n                super(`${use_server}${url}`);\n            }\n        }\n\n    return EventSourceFake;\n}\n\n// @ts-ignore\nclass EventSourceFake extends EventTarget implements EventSource {\n    constructor(url: string) {\n        super();\n        this.url = url;\n\n        globalThis.fetch(url).then( async (response) => {\n\n            this.readyState = this.OPEN;\n            this.dispatchEvent( new Event(\"open\") );\n\n            const reader = response.body!.pipeThrough(new TextDecoderStream).getReader();\n\n            let buffer = \"\";\n            let chunk = await reader.read();\n\n            while( ! chunk.done ) {\n\n                buffer += chunk.value!;\n\n                let pos = buffer.indexOf(\"\\n\\n\");\n                while( pos !== -1) {\n\n                    let event = buffer.slice(0, pos);\n\n                    const data = Object.fromEntries( event.split(\"\\n\").map( l => l.split(\": \") ) );\n\n                    data.event ??= \"message\";\n\n                    this.dispatchEvent( new MessageEvent(data.event, {data: data.data}) )\n\n                    buffer = buffer.slice(pos + 2);\n                    pos = buffer.indexOf(\"\\n\\n\");\n                }\n\n                chunk = await reader.read();\n            }\n        });\n    }\n    onerror  : ((this: EventSource, ev: Event       ) => any) | null = null;\n    onmessage: ((this: EventSource, ev: MessageEvent) => any) | null = null;\n    onopen   : ((this: EventSource, ev: Event       ) => any) | null = null;\n    close(): void {\n        this.readyState = this.CLOSED;\n    }\n\n    readyState: number = 0;\n\n    readonly CONNECTING = 0;\n    readonly OPEN = 1;\n    readonly CLOSED = 2;\n\n    // not implemented\n    url: string;\n    withCredentials: boolean = false;\n}","const WebSocket = globalThis.WebSocket;\n\nexport function getFakeWebSocket(use_server: string|null) {\n\n    if( use_server )\n        return class WebSocketServer extends WebSocket {\n            constructor(url: string) {\n                super(`${use_server}${url}`);\n            }\n        }\n\n    return WebSocketFake;\n}\n\ndeclare global {\n    interface Deno {\n        upgradeWebSocket(req: Request): {\n            socket: WebSocketFake,\n            response: Response\n        };\n    }\n}\n\n// @ts-ignore\nglobalThis.Deno = {\n    upgradeWebSocket: function(request: Request) {\n\n        const socket   = new WebSocketFake(null);\n        const response = new Response();\n\n        (response as any).websocket = socket;\n\n        return {\n            socket,\n            response\n        }\n    }\n}\n\n//TODO implemente Deno.upgrade => return fake Response + ServerWebSocket...\n\nclass WebSocketFake extends EventTarget implements WebSocket {\n\n    other: WebSocketFake|null = null;\n\n    constructor(url: string|null) {\n        super();\n\n        if( url === null)\n            return;\n\n        this.url = url;\n\n        globalThis.fetch(url).then( async (response) => {\n\n            this.other = (response as any).websocket;\n            this.other!.other = this;\n\n            this.readyState = this.OPEN;\n            this.dispatchEvent( new Event(\"open\") );\n            this.other!.dispatchEvent( new Event(\"open\") );\n\n        });\n\n\n    }\n\n    close(code?: number, reason?: string): void {\n        this.readyState = this.CLOSED;\n        let event: CloseEventInit = {};\n        if( code !== undefined)\n            event.code = code;\n        if( reason !== undefined)\n            event.reason = reason;\n\n        this.other!.dispatchEvent( new CloseEvent(\"close\", event) );\n        this.dispatchEvent( new CloseEvent(\"close\", event) );\n    }\n    send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n        this.other!.dispatchEvent(new MessageEvent(\"message\", {data}));\n    }\n\n    url: string = \"\";\n    \n    onclose  : ((this: WebSocket, ev: CloseEvent  ) => any) | null = null;\n    onerror  : ((this: WebSocket, ev: Event       ) => any) | null = null;\n    onmessage: ((this: WebSocket, ev: MessageEvent) => any) | null = null;\n    onopen   : ((this: WebSocket, ev: Event       ) => any) | null = null;\n\n    readyState: number = 0;\n\n    readonly CONNECTING = 0;\n    readonly OPEN       = 1;\n    readonly CLOSING    = 2;\n    readonly CLOSED     = 3;\n\n    // not implemented\n    binaryType: BinaryType = \"arraybuffer\";\n    bufferedAmount: number = 0;\n    extensions: string     = \"\";\n    protocol: string       = \"\";\n}"],"names":["globalThis","EventSource","EventTarget","WebSocket","Deno","upgradeWebSocket","request","socket","WebSocketFake","response","Response","websocket","other","constructor","url","super","this","fetch","then","async","readyState","OPEN","dispatchEvent","Event","close","code","reason","CLOSED","event","undefined","CloseEvent","send","data","MessageEvent","onclose","onerror","onmessage","onopen","CONNECTING","CLOSING","binaryType","bufferedAmount","extensions","protocol"],"sourceRoot":""}