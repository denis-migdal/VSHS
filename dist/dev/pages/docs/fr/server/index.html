<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>VSHS</title>
        <!--
        <meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />
        <meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />
        -->
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link   href="./index.css"  rel="stylesheet" blocking="render">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.13.0/brython.min.js"></script>
        <script  src="./index.js"  type="module"     blocking="render" async></script>
    </head>
    <body>
        <main>

<h1 id="dÃ©marrer-et-requÃªter-le-serveur-http">DÃ©marrer et requÃªter le serveur HTTP</h1>
<p>L&#39;intÃ©gralitÃ© du serveur est contenu dans le fichier <code>./VSHS.ts</code>. Les autres fichiers contiennent les exemples, tests, et documentations.</p>
<h2 id="dÃ©mo-et-tests">DÃ©mo et tests</h2>
<p>Vous pouvez lancer le serveur de dÃ©monstration via la commande <code>deno task demo</code>. Une fois le serveur lancÃ© :</p>
<ul>
<li>lancez les tests unitaires via la commande <code>deno task test</code>.</li>
<li>utilisez le serveur au sein du <a href="../../../playground/">bac Ã  sable</a> en cochant l&#39;option &quot;Server&quot; prÃ©sente en haut de la page.</li>
</ul>
<h2 id="dÃ©marrer-le-serveur">DÃ©marrer le serveur</h2>
<h3 id="en-ligne-de-commandes-cli">En ligne de commandes (CLI)</h3>
<p>Un serveur VSHS peut Ãªtre lancÃ© en lignes de commandes via <code>./VSHS.ts $ROUTES</code>, avec <code>$ROUTES</code> le dossier contenant les <em>requests handlers</em>.</p>
<p>ğŸ’¡ L&#39;option <code>--help</code> permet d&#39;afficher l&#39;usage de la commande.</p>
<h3 id="via-deno-typescript">Via Deno (TypeScript)</h3>
<p><code>VSHS.ts</code> exporte par dÃ©faut une fonction <code>startHTTPServer(opts)</code> permettant de lancer un serveur. <code>startHTTPServer(opts)</code> accepte plusieurs options :</p>
<ul>
<li><code>routes</code> : le chemin du dossier contenant les <em>requests handlers</em>, ou un ensemble de routes.</li>
<li><code>hostname</code>/<code>port</code> : l&#39;ip/port sur lequel le serveur HTTP va Ã©couter.</li>
</ul>
<p>Par exemple :</p>
<pre><code class="language-ts">// myserver.ts
import startHTTPServer from &quot;VSHS&quot;;

startHTTPServer({
    routes: &quot;...&quot;
});
</code></pre>
<p>Vous pouvez ensuite lancer votre serveur via la commande : <code>run --allow-all myserver.ts</code>.</p>
<p>ğŸ’¡ Lors du dÃ©veloppement vous pouvez utiliser les options suivantes :</p>
<ul>
<li><code>--check</code> : vÃ©rifier les types TypeScripts ;</li>
<li><code>--watch=./</code> : relancer le serveur lorsque les fichiers du dossier <code>./</code> sont modifiÃ©s.</li>
</ul>
<p>ğŸ’¡ Vous pouvez aussi <a href="https://docs.deno.com/runtime/fundamentals/configuration/">configurer Deno</a> via les fichiers Ì€<code>deno.json</code> et <code>package.json</code></p>
<h2 id="requÃªter-le-serveur">RequÃªter le serveur</h2>
<h3 id="en-ligne-de-commandes-cli-1">En ligne de commandes (CLI)</h3>
<h4 id="requÃªtes-http-avec-curlwget">RequÃªtes HTTP avec curl/wget</h4>
<p>Les commandes <code>curl</code> et <code>wget</code> permettent d&#39;envoyer des requÃªtes HTTP Ã  un serveur et d&#39;afficher sa rÃ©ponse. Leur usage est dÃ©crit par le tableau ci-dessous :</p>
<style>
table, th, td {
  border: 1px solid grey;
  border-collapse: collapse;
}

tbody th {
    text-align: left;
}

th,td {
  padding: 5px;
}
</style>
<table>
    <thead>
        <tr><td></td><th>curl</th><th>wget</th></tr>
    </thead>
    <tbody>
        <tr><th>Envoyer une requÃªte</th><td>curl "$URL"</td><td>wget -qO- "$URL"</td></tr>
        <tr><th>MÃ©thode HTTP</th><td>-X GET</td><td>--method=GET</td></tr>
        <tr><th>DonnÃ©es</th><td>-d 'Hello'</td><td>--body-data='Hello'</td></tr>
        <tr><th>Ajouter en-tÃªte</th><td>-H "Content-Type: ..."</td><td>
--header="Content-Type: ..."</td></tr>
        <tr><th>En-tÃªte de la rÃ©ponse</th><td>-i</td><td>
-S</td></tr>
        <tr><th>Afficher les en-tÃªtes</th><td>-v</td><td>
--debug</td></tr>
    </tbody>
</table>

<p>Par exemple :</p>
<pre><code class="language-shell">$ curl -X GET &quot;http://localhost:8080/Hello%20World&quot; -w &quot;

Content    : %{content_type}
Status code: %{http_code}
&quot;
Hello World ;)

Content    : text/plain;charset=UTF-8
Status code: 200
</code></pre>
<pre><code class="language-shell">$ curl -X POST -d &#39;{&quot;A&quot;: 42}&#39; &quot;http://localhost:8080/echo%20(body)&quot; -w &quot;\n&quot;
{&quot;A&quot;: 42}
</code></pre>
<p>ğŸ’¡ L&#39;option <code>-w</code> de <code>curl</code> permet de formatter la sortie, notamment en affichant :<br/></p>
<ul>
<li><code>content_type</code></li>
<li><code>http_code</code></li>
</ul>
<h4 id="websockets">WebSockets</h4>
<p>La commande <code>wscat -c $URL</code> permet de se connecter au serveur via un WebSocket, e.g. :</p>
<pre><code>wscat -c &quot;http://localhost:8080/response (WebSocket)&quot;
Connected (press CTRL+C to quit)
&gt; Hello
&lt; Hello
</code></pre>
<p>ğŸ’¡ <code>wscat</code> s&#39;installe via la commande <code>npm install -g wscat</code> (requiert les droits administrateur).</p>
<h4 id="tcp">TCP</h4>
<p>Vous pouvez requÃªter le serveur directement en TCP via la commande <code>nc $HOST $PORT</code>.</p>
<p>Cependant, il vous faudra Ã©crire vous mÃªme les requÃªtes HTTP, e.g.</p>
<pre><code>$ nc localhost 8080
POST /echo%20(body) HTTP/1.1
Content-Type: plain/text
Content-Length: 5

Hello
</code></pre>
<p>ğŸ’¡ L&#39;option <code>-l</code> dÃ©marre un serveur TCP, permettant alors de recevoir des requÃªtes HTTP gÃ©nÃ©rÃ©es par e.g. <code>curl</code>.</p>
<h3 id="via-javascriptbrython">Via JavaScript/Brython</h3>
<h4 id="envoyer-une-requÃªte-avec-fetch">Envoyer une requÃªte avec fetch</h4>
<p>La fonction asynchrone <js-code>fetch(<var>$URL</var>[, <var>$RequestInit</var>])</js-code> envoie une requÃªte HTTP et retourne un <code>Response</code>.</p>
<vshs-playground name="echo (string)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=echo (string)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<p><code>RequestInit</code> peut contenir les champs suivants :</p>
<ul>
<li><code>method</code> : la mÃ©thode HTTP Ã  utiliser (e.g. <code>GET</code>) ;</li>
<li><code>body</code> : le corps de la requÃªte HTTP ;</li>
<li><code>headers</code> : des en-tÃªtes HTTP Ã  ajouter Ã  la requÃªte ;</li>
<li><code>cache</code> : la politique de cache Ã  utiliser ;</li>
</ul>
<p>ğŸ’¡ Vous pouvez aussi construire un <code>Request</code> et le donner en paramÃ¨tre de <code>fetch()</code>:</p>
<vshs-playground name="fetch (request)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=fetch (request)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<p>ğŸ’¡ La construction d&#39;un <code>Request</code> est similaire par bien des aspects Ã  la construction d&#39;un <code>Response</code>.</p>
<p>ğŸ’¡ Pour rÃ©pÃ©ter une requÃªte, vous pouvez construire un <js-code>Request</js-code> que vous clonerez avant de le transmettre Ã  <code>fetch()</code>.</p>
<vshs-playground name="fetch (clone)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=fetch (clone)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<p>âš  Contrairement Ã  <code>Response</code>, <code>Request</code> ne dispose pas pour le moment d&#39;une mÃ©thode statique <code>.json()</code> (cf <a href="https://github.com/whatwg/fetch/issues/1791">issue</a>).<br/>
Il convient alors d&#39;utiliser :</p>
<vshs-playground name="echo (json)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=echo (json)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<h4 id="lire-une-rÃ©ponse">Lire une rÃ©ponse</h4>
<p><code>await fetch()</code> retourne un <code>Response</code> reprÃ©sentant la rÃ©ponse du serveur.</p>
<p>ğŸ’¡ La lecture d&#39;un <code>Response</code> est similaire par bien des aspects Ã  la lecture d&#39;un <code>Request</code>.</p>
<p><code>Response</code> a les propriÃ©tÃ©s suivantes :</p>
<ul>
<li><code>.ok</code> : indique si la rÃ©ponse reprÃ©sente un succÃ¨s ;</li>
<li><code>.status</code> : le code de status HTTP ;</li>
<li><code>.statusText</code> : un message dÃ©crivant le code de status HTTP ;</li>
<li><code>.headers</code> : les en-tÃªtes de la rÃ©ponse HTTP.</li>
</ul>
<vshs-playground name="fetch (read)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=fetch (read)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<h4 id="eventsource">EventSource</h4>
<p>Les <a href="https://developer.mozilla.org/fr/docs/Web/API/Server-sent_events">Server-Sent Events</a> permettent de recevoir progressivement des donnÃ©es du serveur.</p>
<p>On peut alors utiliser <code>new EventSource(url)</code> afin de lire les Ã©vÃ©nements envoyÃ©s par le serveur :</p>
<vshs-playground name="fetch (SSE)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=fetch (SSE)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<p>ğŸ’¡ Progressivement, <code>EventSource</code> a vocation Ã  Ãªtre remplacÃ© par les flux fetch. Cependant, il s&#39;agit d&#39;une API bas niveau.</p>
<h4 id="websocket">WebSocket</h4>
<p>Les <a href="https://developer.mozilla.org/fr/docs/Web/API/WebSocket"><code>WebSocket</code></a> permettent des communications bidirectionnelles asynchrones entre le navigateur et le serveur :</p>
<ul>
<li><code>new WebSocket(url)</code> permet d&#39;initialiser un nouveau WebSocket ;</li>
<li><code>send(data)</code> permet d&#39;envoyer des donnÃ©es ;</li>
<li><code>addEventListener(&#39;message&#39;, ({data}) =&gt; {})</code> permet d&#39;Ã©couter les donnÃ©es reÃ§ues.</li>
</ul>
<vshs-playground name="response (WebSocket)" show="request.code,output">
</vshs-playground>
<div style="text-align:right"><a href="../../../playground/?example=response (WebSocket)"><i>Tester l'exemple dans le bac Ã  sable</i></a></div>

<p>âš  Vous devez attendre que la connexion soit ouverte avant d&#39;envoyer des donnÃ©es (i.e. attendre l&#39;Ã©vÃ©nement <code>open</code>).</p>
<p>ğŸ’¡ Progressivement, les WebSockets ont vocation Ã  Ãªtre remplacÃ©s par l&#39;API <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API"><code>WebTransport</code></a>. Cependant, comme pour les flux, il s&#39;agit d&#39;une API bas niveau.</p>
<p>aaaaaaaaaaaaa<br><c>fetch(<d><e>$URL</e></d><d>[, <e>$RequestInit</e>]</d>)</c><br>bbbbbbbbbbbbb</p>
<style>
c {
    padding:0 .5rem;
    margin: 0 .2rem;
    white-space: nowrap;
    background: #F1F1F1;
    border: 1px solid #E1E1E1;
    border-radius: 4px;
    color:black;

    & > d {

        padding: 0 .5rem;
        margin: 0 .2rem;
        white-space: nowrap;
        background: lightblue;
        font-style: italic;
        border: 1px dashed blue;
        color: gray;
        border-radius: 4px;

        & e {
            color: #ff8c00;
            font-weight: bold;
            font-style: normal;
        }
    }
}
</style>


<script type="c-js">
    const a = 2+2;

    console.log("Hello World"<h>[, $a]</h>);
</script>

<p>aaaaa<br>cc <script type="c-js">const a = 2+2<h>[, $a]</h>;</script> cc<br>bbbbbb</p>
</main>
    </body>
</html>